<!DOCTYPE html>
<html>
  <head>
    <title>Hello Kotlin, Farewell Java</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Hello Kotlin, Farewell Java

![Kotlin logo](images/kotlin.png)

Technozaure Bordeaux - 6 octobre 2017

???
Bonjour !

Aujourd'hui je vais vous parler du langage de programmation Kotlin.

Pour commencer qui a d√©j√† entendu parler de ce langage ?
Qui en a d√©j√† √©crit ?
Qui a d√©j√† √©t√© pay√© pour en √©crire :D ?
Ok, tu peux sortir et revenir dans une heure alors ;-)

---

# Agenda

1. A brief history
2. Why ?
3. Object
4. Val vs Var
5. Type inference
6. To be null or not to be null ?
7. Smart type checks
8. The case for when
9. DTO
10. Wow more such very goodies
11. Fun, Fun, Fun
12. Conclusion

???

Le format de la conf√©rence est plut√¥t un format atelier.
Je vais commencer par faire une pr√©sentation rapide du langage et nous verrons ensemble quelques fonctionnalit√©s int√©ressantes propos√©es. J'ai volontairement limit√© ce nombre sinon la pr√©sentation aurait dur√© une heure et vous auriez eu quelques minutes seulement pour manipuler :p

Un disclaimer avant d'attaquer : j'adore Kotlin, j'aime aussi Scala :D

---

# A brief history

![Kotlin island](images/kotlin-island.jpg)

???

Ah mince une photo de mes derni√®res vacances s'est gliss√©e dans la pr√©sentation !

Il s'agit de l'√Æle de Kotlin, situ√©e √† une trentaine de kilom√®tres de Saint-Petersbourg

---

# A brief history

<img src="images/jetbrains.png" alt="Jetbrains logo" width="200" height="200">

* Development started in 2010

* Officially announced in 2011

* Endorsed by Google in 2017


???

Le d√©veloppement de Kotlin a commenc√© en 2010 au sein de Jetbrains, qui poss√®de des locaux √† Saint-Petersbourg, d'o√π la photo pr√©c√©dente. La boucle est boucl√©e.

Il a √©t√© officiellement annonc√© en 2011 au JVM Language Summit.
De nombreuses versions milestone se sont succ√©d√©es et finalement la version 1.0 a √©t√© livr√©e le 15 f√©vrier 2016. Heureusement qu'ils ont attendu un jour sinon j'aurais d√ª annuler le restaurant de la Saint-Valentin :p

En mai 2017 Google a annonc√© le support officiel du langage pour le d√©veloppement d'applications Android.

---

# Why ?

<img src="images/website.png" alt="Kotlin website" width="800" height="500">

???

Le site officiel de Kotlin, RAS :)
Ah si, les cibles, Android, JavaScript, bient√¥t natif.
Et pour les amateurs, le site est fait en React, Bruno ;-)

---

# Why ?

* For Jetbrains internal use

* Adopted by Android community

* What Java should have been

???

√Ä l'origine d√©velopp√© en partie pour un usage interne avec les contraintes suivantes :

  - interop√©rabilit√© compl√®te avec du code Java (grosse base de code en Java en interne)
  - compilation aussi rapide que Java (entra√Æne des arbitrages sur le syst√®me de types)
  - plus "safe" que Java
  - plus concis que Java (bon ok celle-l√† elle est facile)
  - plus simple que Scala

On peut r√©sumer Kotlin comme "Java meet Scala" ou "Java++". Les mauvaises langues diront m√™me qu'il est le langage que nous m√©ritons, mais pas celui dont nous avons besoin ou qu'il est ce que Java aurait d√ª √™tre.

---

background-image: url(images/object.jpg)

# Object

???

Contrairement √† Java pas de type primitif, yeah :).
Le compilateur est assez intelligent pour g√©rer √ßa comme un grand ;-)

Tout en haut nous avons la classe `Any` dont tout type est un sous-type. Cette classe n'a AUCUN membre (contrairement √† java.lang.Object)
Tout en bas nous avons la classe `Nothing`, qui indique l'absence de valeur. Tout type est un super-type de `Nothing`.
Apr√®s nous retrouvons les types classiques String, Int, Double, Boolean, Array, Unit(void) ...

---

# Val vs Var

```kotlin
fun main(args: Array<String>) {
  val s: String = "Hello, Kotlin"
  s = "Farewell, Java" // compile error
  println(s)

  var n: Int = 1
  n += 1
  println(n) // 2

  val arr: Array<Int> = Array(5) { it }
  arr[1] = 0
  arr.forEach { print("$it ") } // 0 0 2 3 4
}
```

???

Kotlin propose deux mots-cl√© pour d√©finir des variables :

  - `val` (value) pour des r√©f√©rences immuables.
  - `var` (variable) pour des r√©f√©rences muables.

On peut rapprocher cette notion de JavaScript (const/let) ou Scala (val/var/def)

**Attention** une r√©f√©rence immuable vers une structure muable ne rend pas la structure immuable.

On peut remarquer au passage le mot cl√© utilis√© pour d√©finir une fonction : `fun`.
Ce n'est pas forc√©ment quelque chose de nouveau, le langage ML l'utilisait d√©j√† en 1970.
---

# Type inference

```kotlin
  val s = "Hello, Kotlin" // String is inferred
  val n = 2               // Int is inferred

  fun add(a: Int, b: Int): Int = a + b
  val sum = add(1, 2)     // Int is inferred
```

Rule of thumb üëç

Use type in `fun` declaration, not necessarily in variable declaration.

???

Kotlin est capable d'inf√©rer les variables, ainsi que les fonctions expressions.
Afin de garder un temps de compilation acceptable, les fonctions blocks ne sont elles pas inf√©r√©es (oui `scalac` c'est toi que je regarde).

---

background-image: url(images/null.jpg)

# To be null or not to be null ?

???

La citation par excellence :
> I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.

---

# To be null or not to be null ?

```kotlin
val s: String = null   // compile error
val s2: String? = null // OK

println(s2.length)     // compile error
println(s2!!.length)   // üòà
if (s2 != null) println(s3.length) // OK, smart cast as String
if (s2 != null &amp;&amp; s2.length > 0) println("non-empty string") // OK too
```

???

Par d√©faut les types dans Kotlin ne sont pas nullables :-).
Il faut explicitement indiquer le type comme nullable en ajoutant un `?` au nom du type (String?).
√Ä ce propos tous les types manipul√©s par le biais de code Java sont forc√©ment nullables.

Kotlin offre plusieurs facilit√©s pour manipuler les types nullables :

  - smart cast : une fois le test de nullit√© fait, le compilateur consid√®re la valeur comme non nulle.
  - l'op√©rateur `?` qui renvoie la valeur nulle si la variable manipul√©e est nulle. Cet op√©rateur peut √™tre cha√Æn√©.
  - ...

---

# Smart type checks

```kotlin
val obj = gimme()
if (obj is String) println("$obj has ${obj.length} characters")

if (obj !is String) println("Not a string üòû") // could have been !(obj is string)
else println(obj.length)

fun gimme(): Any =
  when (ThreadLocalRandom.current().nextBoolean()) {
    true -> "Hello, Kotlin"
    false -> 1
  }
```

???

De la m√™me mani√®re les smart type checks permettent de valider un objet comme d'un certain type une fois le test fait.

---

# The case for when

```kotlin
val x: Any = 1
when (x) {
  0, 1 -> print("x is 0 or 1")
  is String -> print("x is a String")
  else -> println("ü§î")
}

// when as an expression
val isBigNumber = when {
  n &lt; 100 -> false
  n >= 100 -> true
  else -> println("ü§î")
}

// compiler can detect if else branch is needed
val b = when (ThreadLocalRandom.current().nextBoolean()) {
  false -> 0
  true -> 1
  else -> -1 // unneeded
}
```

???

Il n'y a pas d'op√©rateur `switch` (oooohhh). Mais rassurez-vous, il y a l'op√©rateur `when`, bien plus puissant (aaaahhhh).
On peut l'utiliser comme un `switch` mais il s'apparente plus √† une op√©ration de pattern matching.
√Ä noter qu'il s'agit d'une expression, elle peut donc √™tre utilis√©e pour une fonction expression.

---

# DTO

```java
import java.util.Objects;

public class User {
    private final String login;
    private final String password;

    public User(String login, String password) {...}
    public String getLogin() {...}
    public String getPassword() {...}
    @Override public String toString() {...}
    @Override public boolean equals(Object o) {...}
    @Override public int hashCode() {...}
    // 41 lines !
}
```

<img src="images/vs.png" style="display:block; margin: 0 auto;">

```kotlin
data class User(val login, val password)
```

???

Le slide se passe de commentaires non ?

Pas besoin d'utiliser d'outils qui g√©n√®re du code √† la compilation et qui n√©cessite un support de l'IDE.
Ici tout est support√© par le langage.

Le simple fait de rajouter le mot `data` nous offre :

  - les accesseurs
  - les mutateurs pour les propri√©t√©s mutables
  - les m√©thodes `toString`, `equals`, `code`
  - des m√©thodes de copie des objets, √©ventuellement en modifiant certaines propri√©t√©s.


---

# Wow more such very goodies

#### Extensions function

```kotlin
fun Int.isEven() = this % 2 == 0
println(1.isEven())
```

#### Destructuration

```kotlin
val (x, y) = randomPair()
println("$x - $y")
fun randomPair(): Pair<Int, Int> {
  fun nextRandomInt() = ThreadLocalRandom.current().nextInt() // nested function
  
  return Pair(nextRandomInt(), nextRandomInt())
}
```

#### Type alias

```kotlin
typealias Users = List&lt;User>
```

???

J'ai fait √† peu pr√®s le tour des grosses fonctionnalit√©s que je voulais vous pr√©senter mais il en reste plein d'autres :-)
Nous allons finir par faire un tour rapide de quelques fonctionnalit√©s tr√®s agr√©ables.

Les fonctions d'extension, ou comment vous pouvez enfin rajouter une m√©thode au type `String`. Oui oui, vous avez bien entendu :-)

La destructuration d'objets, bien connus des amoureux du JavaScript si il y en a ici ;-)
Au passage on peut remarquer aussi l'existence d'un type Pair, en standard dans la librairie. Il existe aussi un type `Triple`. Ils se sont arr√™t√©s l√†, contrairement √† d'autres. En effet √† partir de quatre valeurs renvoy√©es il faudrait peut-√™tre r√©fl√©chir un peu plus √† notre domaine.

Pour finir sur cette slide les alias de type, plut√¥t pratique pour rendre plus expressif notre code.

---

# Wow more such very goodies

#### Ranges

```kotlin
val countdown = 10 downTo 0
for (n in countdown) println(n)
```

#### Safe calls

```kotlin
val s: String? = string()
val length: Int? = s?.length // length or null
println(user?.login?.length) // can be chained
```

#### Elvis operator

```kotlin
val length: Int = s?.length ?: 0
println(user?.login?.length ?: throw NullPointerException())
```

#### Infix functions

```kotlin
infix fun Int.inc(n: Int) = this + n
println(10 inc 2)
```

???

On continue avec :

  - les ranges et les op√©rations `..`, `downTo`, `step` qui permettent de facilement it√©rer sur une liste de valeurs finies
  - les safe calls pour les types nullables (d√©j√† vu)
  - l'op√©rateur Elvis, qui permet de renvoyer une valeur √† la place de `null` et ainsi sortir du monde dangereux des types nullables.
  - les fonctions `infix`

---

# Wow more such very goodies

#### Default arguments

```kotlin
@JvmOverloads
fun add(a: Int, b: Int = 1) = a + b
add(1, 2) // 3
add(1)    // 2
```

#### Named arguments

```kotlin
println(add(b = 2, a = 1))
```

#### Interoperability

```java
public class Interop {
    public static void main(String[] args) {
      System.out.println(MathsKt.add(1, 2));
      System.out.println(MathsKt.add(1));
    }
}
```

???

Enfin pour finir beaucoup de sucre et un peu d'interop√©rabilit√© :

  - on peut d√©finir des valeurs par d√©faut pour les arguments des fonctions (clin d'oeil aux d√©veloppeurs JS).
    Cela √©vite les m√©thodes surcharg√©es (clin d'oeil aux d√©veloppeurs Java)
  - on peut appeler une fonction en changeant l'ordre des param√®tres si on les nommes, cela est surtout int√©ressant combin√© avec le point pr√©c√©dent.

Concernant l'interoperabilit√© on peut voir un exemple, notre classe sera nomm√©e &lt;ClasseKT, il est possible de changer ce comportement en utilisant l'annotation `@JvmName("name")` ou @file:JvmName("name").
On voit aussi que l'on peut demander au compilateur de g√©n√©rer les m√©thodes surcharg√©es si notre fonction fournit des valeurs par d√©faut pour certains arguments.

---

# Fun, Fun, Fun

Go, go, go workshop !

**TODO** ajouter l'url du workshop sur Tech.io

???

C'est √† vous maintenant :-)

J'ai profit√© de l'occasion pour tenter de faire l'atelier sur Tech.io. Vous connaissez ?
Je me suis malheureusement heurt√© √† certaines difficult√©s, on verra ce que cela donne :-)
Ne reproduisez pas cela chez vous :p

---
class: center, middle

# Conclusion

???

Kotlin, jetez-vous !

---

# Resources

* [Kotlin Reference](https://kotlinlang.org/docs/reference/)

* [Try Kotlin](https://try.kotl.in/)

* [Awesome Kotlin](https://github.com/KotlinBy/awesome-kotlin)

* [Kotlin in Action](https://www.manning.com/books/kotlin-in-action)

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightStyle: "monokai"
      });
    </script>
  </body>
</html>
